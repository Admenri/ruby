# Generate src/hir_type_generated.rs. To do this, we build up a DAG that
# represents a slice of the Ruby type hierarchy that we care about optimizing.
# This also includes primitive values such as C booleans, int32, and so on.

require 'set'

# Type represents not just a Ruby class but a named union of other types.
class Type
  attr_accessor :name, :subtypes

  def initialize name, subtypes=nil
    @name = name
    @subtypes = subtypes || []
  end

  def all_subtypes
    subtypes + subtypes.flat_map { |subtype| subtype.all_subtypes }
  end

  def subtype name
    result = Type.new name
    @subtypes << result
    result
  end
end

# Helper to generate graphviz.
def to_graphviz_rec type
  type.subtypes.each {|subtype|
    puts type.name + "->" + subtype.name + ";"
  }
  type.subtypes.each {|subtype|
    to_graphviz_rec subtype
  }
end

# Generate graphviz.
def to_graphviz type
  puts "digraph G {"
  to_graphviz_rec type
  puts "}"
end

# ===== Start generating the type DAG =====

# Start at Top. All types are subtypes of Top.
top = Type.new "Top"
# Build the Ruby object universe.
object = top.subtype "Object"
object.subtype "ObjectExact"
$object_user = object.subtype "ObjectUser"
$user = top.subtype "User"
$builtin_exact = object.subtype "BuiltinExact"

# Define a new type that can be subclassed (most of them).
def base_type name
  type = $object_user.subtype name
  exact = type.subtype(name+"Exact")
  user = type.subtype(name+"User")
  $builtin_exact.subtypes << exact
  $user.subtypes << user
  [type, exact]
end

base_type "String"
base_type "Array"
base_type "Hash"

(integer, integer_exact) = base_type "Integer"
# CRuby partitions Integer into immediate and non-immediate variants.
integer_exact.subtype "Fixnum"
integer_exact.subtype "Bignum"

(float, float_exact) = base_type "Float"
# CRuby partitions Float into immediate and non-immediate variants.
float_exact.subtype "Flonum"
float_exact.subtype "HeapFloat"

(symbol, symbol_exact) = base_type "Symbol"
# CRuby partitions Symbol into immediate and non-immediate variants.
symbol_exact.subtype "StaticSymbol"
symbol_exact.subtype "DynamicSymbol"

base_type "NilClass"
base_type "TrueClass"
base_type "FalseClass"

# Build the primitive object universe.
primitive = top.subtype "Primitive"
primitive.subtype "CBool"
primitive.subtype "CPtr"
primitive.subtype "CDouble"
primitive.subtype "CNull"
primitive_int = primitive.subtype "CInt"
signed = primitive_int.subtype "CSigned"
unsigned = primitive_int.subtype "CUnsigned"
[8, 16, 32, 64].each {|width|
  signed.subtype "CInt#{width}"
  unsigned.subtype "CUInt#{width}"
}

# Assign individual bits to type leaves and union bit patterns to nodes with subtypes
num_bits = 0
bits = {"Bottom" => ["0u64"]}
Set[top, *top.all_subtypes].sort_by(&:name).each {|type|
  subtypes = type.subtypes
  if subtypes.empty?
    # Assign bits for leaves
    bits[type.name] = ["1u64 << #{num_bits}"]
    num_bits += 1
  else
    # Assign bits for unions
    bits[type.name] = subtypes.map(&:name).sort
  end
}

# ===== Finished generating the DAG; write Rust code =====

puts "// This file is @generated by src/gen_hir_type.rb."
puts "mod bits {"
bits.keys.sort.map {|type_name|
  subtypes = bits[type_name].join(" | ")
  puts "  pub const #{type_name}: u64 = #{subtypes};"
}
puts "  pub const AllBitPatterns: [(&'static str, u64); #{bits.size}] = ["
bits.keys.sort.map {|type_name|
  puts "    (\"#{type_name}\", #{type_name}),"
}
puts "  ];"
puts "  pub const NumTypeBits: u64 = #{num_bits};
}"

puts "pub mod types {
  use super::*;"
bits.keys.sort.map {|type_name|
    puts "  pub const #{type_name}: Type = Type::from_bits(bits::#{type_name});"
}
puts "}"
